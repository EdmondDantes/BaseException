# Paradigm

Исключения с точки зрения анализа Программного Обеспечения (ПО), представляют собою особый интерес, так как описывают отклонения от "идеального множества состояний". В теории, имея такую информацию программисты должны были бы быстро находить причины сбоев. Но теория, слишком часто остаётся наедине сама с собой.

Нередко бывают ситуации, когда поток исключений не только становится многочисленным, но и совершенно не воспроизводимым (повторное воспроизведение). А, иногда некоторые ошибки возникают спонтанно, без какой либо корреляции, словно эмоции у психопата[^1]. В конце концов дело доходит до полного игнорирования "непонятных" проблем. Хотя это не значит, что проблемы не "влияют" на умы разработчиков.

Известное "Кто владеет информацией…" следовало бы уточнить: "Кто понимает…", или если уже совсем близко к теме: "Кто анализирует данные…" :). Но создание анализируемых журналов натыкается на "непреодолимые" препятствия:

1. Структура журнала и связанный код часто меняются. (Особенно после завершения проекта)
2. На реализацию кода журналирования никогда не хватает времени. А для кода анализа - и подавно!
3. Код журналирования уродует "целевой" код.
4. Код, обслуживающий формирование журнала считается "нудным" :)[^2]

Вспоминается:

```php
    try
    {
        ...
    }
    catch(\Exception $e)
    {
        err_log($e);
        // ^^^^^^^^^ - этого кода не должно здесь быть!
        // а значит и try/catch тоже :)

        throw $e;
    }
```

На самом деле основных причин две:

1. Смешение целевого кода и кода журналирования.
2. Структурирование информации для журнала.

А решение вопросов частого изменения структуры журнала и кода журналирования вполне можно решить при помощи обобщённого программирования.

## Полковнику никто не пишет

В фильме "Как украсть миллион" есть хорошая демонстрация эффекта "ЗАЯ"[3]: грабители несколько раз умышленно приводят в действие систему сигнализации. Охранники ничего не обнаруживают. И после очередной попытки систему отключают.

А ведь вроде как обеспечили хорошие журналы, множество методов оповещения:

- сбор логов по серверам,
- письма,
- sms.

Почему же всё это "добро" не приносит пользы? Потому что работает замечательный "человеческий фактор":

1. Человек способен эффективно различать только два вида сигналов.
2. Если один тип сигнала означает "опасность", но используется относительно часто или имеет закономерность, он утрачивает значение.
3. Если сигнал "опасность" должен быть вычленен между множества других сигналов, он утрачивает эффективность обнаружения.

Иначе:

1. Если у ошибок есть несколько уровней, то для человека имеют значения только два: "конец света" и "как нибудь проживём".
2. Если ошибки типа "конец света" возникают достаточно часто, они воспринимаются так же как и ошибки других уровней.
3. Если человек пытается найти ошибку "деление на ноль" среди массива ошибок: "файл не найден", он скорее всего бросит это занятие, даже если будет работать поиск.

Перед нами тот случай, когда архитектура ПО относительно технических аспектов обладает более низким приоритетом по сравнению с психологией восприятия, которая ставит три задачи упорядочивания ошибок по аспектам:

1. Важность: критическая или нормальная.
2. Источник: где возникла ошибка: система, класс, функция. 
3. Причинность (кто виноват): пользователь, внешняя система, программист.

## Инфраструктура исключений

С тех пор, как в языки программирования (и конечно же в Операционные Системы) пришли исключения, появилось понятие потока ошибок: как отдельного потока управления.

Исключения дали возможность избежать "избыточного кода" при обработке ошибок: блок программы может реагировать только на тот тип исключений, который интересует его. Поэтому создание хорошей инфраструктуры исключений (или скажем структуры классов) является приоритетной задачей.

То есть программист обязан определить классы исключений, так как они будут участвовать в логике. Такие классы нельзя считать "избыточным кодом" (хотя и целевым тоже). 

Что если, к задаче создания инфраструктуры исключений добавить решение вышестоящих вопросов:

1. Определение степени критичности.
2. Определение структуры журналируемых данных.
3. Определение источника возникновения.
4. Определение аспекта причинности.
5. Определение кода журналирования.

И избавиться от проблем:

1. Код журналирования уйдёт из целевого кода.
2. Тот, кто использует исключение больше не будет думать о его аспектах.
3. Код определения структуры, журналирования и аспектов находится в одном месте, а не разбросан по всему проекту.
4. А значит: код исключения теперь можно реализовать и изменить в любой момент.

## Структурирование данных

Как правило, исключение позволяет задать всего два вида пользовательских данных:

1. Текст исключения.
2. Код исключения.

Если программисту нужно нечто большее, он может унаследовать от `Exception` свой класс, и сделать так:

```php

    class MyException()
    {
        private $counter;
        
        public function __construct(Object $object)
        {
            $this->counter = $object->get_counter();
            parent::__construct('Error Object Format for '.$object->get_name());
        }
    
        // Специальный метод
        public function get_counter()
        {
            return $this->counter;
        }
    }
   
... 
    // Теперь можно использовать так:
    $object = new Object();    
    … 
    throw new MyException($object);

...
    // где-то в другой галактике поймали исключение
    catch(MyException $e)
    {
        if($e->get_counter() === 0)
        ...
    }
```

Такой подход даёт следующие плюсы:

1. Для внешнего кода появляется возможность обрабатывать только исключение `MyException`.
2. Теперь не нужно помнить текст исключения.
3. Целевой код выглядит проще и чище.
4. Вместе с `MyException` можно передавать дополнительную информацию об ошибке.

Теперь вернёмся к вопросу журналирования. Если исключение попадёт в обычный журнал, то как правило сохранятся только сообщение, код ошибки, и `trace`. Но в `trace` очень много данных, и обычно они оказываются не нужны. А вот как бы сделать так, чтобы с одной стороны данные были упорядочены, а с другой стороны - в них не было бы лишней информации.

Можно текст исключения формировать в *json*, тогда уже после записи в журнал мы всегда сможем проанализировать данные. Но тогда теряется текст исключения, и мы вторгаемся на поле игры Языка Программирования. 

Интереснее выглядит вариант при котором данные размещаются в отдельном свойстве, которое будет ассоциативным массивом. Почему ассоциативный массив? Потому что его просто расширять. Массив не обязан содержать какие-то конкретные ключи. Разные исключения могут определять свои ключи, а с точки зрения журнала - формат массива не имеет значения.

В этом специальном свойстве будут храниться только самые важные данные, которые  интересны при рассмотрении исключения. Эти данные можно использовать и во время выполнения. Главное, что для ассоциативного массива возможен обобщённый код, который будет работать с различными исключениями, но сохранять структуру дополнительных данных.

## Журналирование

Допустим, что структура обобщённого исключения выглядит так:

- `message` - сообщение;
- `code`    - код ошибки;
- другие стандартные данные вроде `line`, `file`;
- `data`    - дополнительные данные: всегда ассоциативный массив.

Осталось понять: как это журналировать?

Можно журналировать прямо в целевом коде, но мы уже говорили, что данный подход изначально некорректен. Можно журналировать в обработчике "необработанных" исключений, но тогда, что делать с такими исключениями, которые были пойманы? Ведь возможна ситуация, когда критическую ошибку просто подавили. Программа отказывает работать, но уже не понятно отчего. Остаётся единственный вариант: журналировать исключение прямо в 
конструкторе.

У этого решения есть свои недостатки. Главный из них - невозможность изоляции кода регистрации исключения: этот код должен быть представлен глобальным объектом (классом или функцией). Этот недостаток так же намекает о том, что данный механизм следует поддерживать на уровне языка программирования, и что подобное решение относительно "совершенной чистоты кода" - костыль.

Однако на практике, этот недостаток не оказывается настолько страшным:

1. Во-первых сложно найти системы, где исключения имеют больше одной точки сбора.
2. Во-вторых, если и нужна другая точка сбора, то её можно перегрузить в дочернем классе.

Невозможно будет лишь сделать что-то такое:

```future

    ...
    // где-то в далёкой галактике… 
    function Destroy_All_Humans(CErectus human)
    {
        throw new Divide_by_zero(human);
    }
    ...

    // Определение потока ошибок
    define error_stream System
    {
        // код помощи человекам
        Exception Rescue_People 
        {
            … 
        }
    }
    
    // Включение зоны ошибок
    @error_stream System
    {
        // Исключение попадает в System
        Destroy_All_Humans();
        
        @error_stream My
        {
            // Исключение попадает в My
            Destroy_All_Humans();
        }
    }

```

Остаётся так же ещё один вопрос: что делать для тех исключений, которые не журналируются сами, когда их нужно подавить, но записать в журнал? Выходит, не получиться уйти от кода логирования в целевом коде?

Тут можно использовать принцип приведения: если у нас есть алгоритм для ситуации А, но мы находимся в B, то нам иногда проще свести B в А[^4]. На практике это выглядит как создание контейнера для исключения:

```php
    try
    {
        ... 
    }
    catch(\Exception $e)
    {
        // Привели исключение к нужному типу данных
        new LoggableException($e);
        // А можно было ещё и указать аспект
        new SystemException($e);
    }
```

Получается логичный код, который кратко выражает суть:

1. Создали исключение `new`: значит есть проблема.
2. Не использовали `throw`: значит программа может работать дальше.

При этом никакого кода журналирования!

В остальном данное решение полно важных достоинств:

1. Исключение будет журналировано даже, если будет подавлено.
2. Код журналирования находится не в основном потоке программы.
3. Каждое исключение способно решать: нужно ли ему журналироваться или нет.

Третий пункт является весьма важным, так как позволяет повысить качество журнала: журнал содержит только на самом деле нужные данные.

## Аспекты причинности

Извечный "русский вопрос": "кто виноват и что делать" так же неплохо звучит на паперти потока ошибок. Как только становится ясно, что виноватых больше чем один - виноватым становится "никто"[^5].

Мне удалось наблюдать не раз замечательную эпопею, когда причиной сбоя программы были административные проблемы вроде прав записи в файловой системе. В результате всё остальное заранее списывалось на эту проблему. Администраторы говорили: "всё дело в вашей программе". Программисты: "нет - у вас кривые настройки".

Этого можно было бы избежать, если предоставить администраторам специальный журнал ошибок, причиной которых является "система". В этом случае, вопросов: "кто виноват, и что делать" возникало бы на порядок меньше.

Разделение ошибок по причинам или источникам их возникновения - идея не новая. Но отчего-то незаслуженно забываемая[^6]. Кроме того, эта идея часто реализована в худшем варианте: когда причин ошибок больше, чем нужно. Мы уже говорили об этом раньше при обсуждении "конца света": человек хорошо реагирует только на два сигнала.

Поэтому я предлагаю ввести всего два аспекта причинности:

1. Системные ошибки - ошибки вызванные системой, с которой взаимодействует программа.
2. Ошибки выполнения - ошибки вызванные внешней средой, которая взаимодействует с программой.

А третий аспект ошибок (так сказать номер 0): ошибки по вине программиста. Будем считать, что таких ошибок быть не может :). Поэтому базовых аспекта всего лишь два.

Всё это хорошо демонстрируется на схеме:

        [Env]     ->  (Program)   ->   [System]
          |               |                |
    RuntimeErrors       Errors        SystemErrors  

где:

- *Env*         - внешняя среда, которая работает с *Program*;
- *Program*     - то, что мы создали;
- *System*      - ОС, или другие программы, с которыми работает *Program*.

`RuntimeErrors` может использоваться и для ошибок конфигурации. Хотя конфигурация обычно является частью системы (`Program`), и часто создаётся самими программистами. Использование аспекта остаётся оправданным по той причине, что ошибка не относится к коду программы. Либо, если группа программистов, создающая конфигурацию, является внешней по отношению к авторам кода, тогда конфигурацию следует считать "внешними данными".

## Степень критичности

Как уже говорилось имеет смысл выделять всего две степени критичности ошибки:

1. Фатальные ошибки.
2. Обычные ошибки.

Фатальной считается ошибка (исключение), если она соответствует трём критериям одновременно:

1. Причина серьёзна, а следствием является полная неработоспособность программы.
2. Ошибка будет воспроизводится постоянно (с высокой вероятностью).
3. Для устранения причин потребуется вмешательство специалиста.

Если исключение не попадает хотя бы под один критерий, оно не может считаться фатальным.

Фатальные исключения обрабатываются иначе, чем обычные ошибки:

1. Код обработки следует делать "тихим" (без ошибок и других исключений), простым и тщательно тестированным.
2. Код обработки может находиться в условиях нехватки ресурсов (дисковое пространство, память, процессорное время).
3. Программа может запретить выполнение своих сервисов, пока проблема не будет решена (помогает выйграть ресурсы и остановить потерю данных).
4. Программа может запустить специальный процесс для анализа и решения проблем.

В вашей программе не должно быть много видов "фатальных ошибок". В противном случае, фатальные ошибки будут пониматься как обычные. Вы обязаны подходить с особым недоверием при внедрении новой фатальной ошибки.

## Источник ошибок

Кроме записи типа исключения для журнала ошибок так же необходимо логирование источника исключения. В `PHP` вроде бы такую задачу призваны решать методы `Exception::getFile()`, `Exception::getLine()`. Однако они весьма далёки от совершенства, так как зависят от файловой структуры.

Более надёжным, переносимым методом указания источника ошибок следует считать полное имя класса. Начиная с `PHP 5.3` оно содержит так же и `namespace`, а значит, позволяет указать не только класс возникновения ошибки, но и систему классов, в которой класс находится.

Это оказывается весьма удобным, особенно когда `namespace` повторяет структуру папок и файлов с исходным кодом. В этом случае информация `Exception::getFile()` не имеет никакого смысла.

## Отладочная информация

С целью отладки иногда требуется записать в журнал такие данные, которые в обычном режиме не нужны. Поэтому было бы правильным внести в нашу парадигму: отладочную информацию. Её так же стоит представлять в виде ассоциативного массива, или же в виде строки отформатированных данных.

Так как отладочная информация нужна только в момент тестирования, следует предусмотреть возможность простого отключения и включения режима. А так же возможность включения режима только для некоторых классов. Это позволит собирать отладочные данные только нужного типа, и причём на "рабочей системе".


--------
[^1]: Я называю это НЕИИ: непрограммируемый искусственный интеллект :)
[^2]: Эту причину стоит считать серьёзной, так как она является дизмотивирующей.
[^3]: Непереводимая и неповторимая игра слов :)
[^4]: Как в одном хорошем анекдоте про алгоритм заварки чая: если чайник уже полный, нужно просто вылить воду из чайника и начать с начала :).
[^5]: Или же мифический "козел отпущения"
[^6]: Иногда даже кажется, что люди склонны забывать всё хорошее, но отлично запоминать дурость.
