# BaseException

`BaseException` - базовый класс библиотеки, от которого наследуются исключения. Он содержит реализацию всех основных методов, определяет все основные свойства.

`BaseExceptionI` - базовый интерфейс для всех объектов, которые поддерживают парадигму библиотеки. Этими объектами могут быть не только исключение, что делает возможным участие пользовательских объектов, не предназначенных для `throw`, но предназначенных для журналирования.

## Конструктор

Конструктор `BaseException` имеет три режима работы:

1. Стандартный (как это определено в `\Exception`).
2. Режим структурированных данных.
3. Режим контейнера.

Наследуемые исключения могут так же прозрачно поддерживать эти режимы, а могут закрывать их своим конструктором.

Например, класс `UnexpectedValue`, может вести себя как `BaseException`, если параметр `$name` будет иметь тип отличный от скаляра.

```php
    class UnexpectedValue   extends LoggableException
    {
        public function __construct($name, $value = null, $rules = null)
        {
            if(!is_scalar($name))
            {
                parent::__construct($name);
                return;
            }

            parent::__construct
            (
                array
                (
                    'message'     => 'Unexpected value',
                    'name'        => $name,
                    'value'       => self::truncate($value),
                    'rules'       => $rules,
                    'type'        => self::get_value_type($value)
                )
            );
        }
    }
```

В остальных случаях, `UnexpectedValue` фомирует данные самостоятельно.

## Шаблоны сообщений

Исключения содержат свойство `message`, которое в общем случае является уникальным для каждого экземпляра класса, что исключает возможность интернационализации. Также с точки зрения разделения знаний лучше не смешивать описание ошибки с данными из контекста.

Шаблоны сообщений решают данную задачу, определяя текст шаблона ошибки, который формирует сообщение `message`.

Так как базовый класс `\Exception` запрещает переопределять метод `getMessage()`, шаблон формируется в отдельном свойстве `template` и может быть инициализирован через конструктор `BaseException`. Однако правилом хорошего тона является определение шаблона в дочернем классе, при помощи переопределения свойства:

```php
class UnexpectedValueType   extends LoggableException
{
    protected $template         = 'Unexpected type occurred for the value {name} and type {type}. Expected {expected}';
```

Формат строки шаблона соответсвует правилам [PSR-3](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md). 

Если исключение определяет шаблон, тогда конструктор `BaseException` работает иначе:

1. *Placeholders* шаблона заменяются данными из контекста, и передаются в конструктор `\Exception`. Таким образом, метод `getMessage()` вернёт полный текст ошибки.
2. Если в конструктор `BaseException` передано свойство `message`, оно воспринимается как дополнительное сообщение, и присоединятся к результирующему сообщению через точку. Например:

```php

        $exception                  = new BaseException
        ([
            'template'              => 'This is the template',
            'message'               => 'This is a message'
        ]);
        
        echo $exception->getMessage();

// Result:
// This is the template. This is a message

``` 

## Наследование

В большенстве случаев дочерний класс переопределяет только конструктор, так как ему нужно сформировать данные исключения.

Если дочернему классу требуется изменить поведение исключения, он может изменять унаследованные свойства. В данном случае - это поведение является нормальным.

Упрощённый алгоритм `BaseException::__construct`:

1. Анализировать входные данные.
2. Вызвать родительский конструктор `\Exception`.
3. Если `BaseException::is_loggable` журнализировать исключение.
4. Если `BaseException::is_fatal` вызвать обработчик фатальных исключений.

Конструктор может изменять любые свойства после своего вызова. Поэтому, если вам нужно модифицировать свойства класса окончательно, делайте это после вызова базового конструктора.

Изменение свойств флажков (с префиксом `is_`) вызывает изменение в поведении базового конструктора.

Например, вот так можно включить журналирование:

```php
    class LoggableException extends BaseException
    {
        /**
         * Флаг логирования.
         * Если флаг равен true - то исключение
         * собирается быть записанным в журнал.
         *
         * @var         boolean
         */
        protected $is_loggable  = true;
    }
```

А вот это исключение является фатальным:

```php
    class MyException extends BaseException
    {
        protected $is_fatal  = true;
    }
```

Класс `BaseException` не журналируется и не имеет аспектов. Поэтому для наследования удобно иметь дополнительные "базовые исключения":

1. `LoggableException` - для исключений, которые журналируются.
2. `SystemException`   - для исключений с аспектом "системное".
3. `RuntimeException`  - для исключений с аспектом "runtime".
4. `FatalException`, `FatalRuntimeException`, `FatalSystemException` - для фатальных исключений.

(подробнее о журнализировании в разделе: [Журналирование][1])

## Рекомендации по формированию данных

Обратите внимание, что конструктор `BaseException` не изменяет данные, которые вы передаёте ему. Эту работу обязаны делать дочерние исключения.

Хорошо придерживаться рекомендаций:

1. Не хранить в исключении объекты.
2. При формировании `data` усекать данные.
3. Сохранять только самое важное и необходимое.
4. Использовать в массиве `data` только базовые типы: скаляры и массивы.

### Не хранить в исключении объекты

Исключения могут попадать в журнал, и хранится в памяти намного дольше, чем объекты, переданные в исключение. Таким образом, вы будете раздувать приложение, так как сборщик мусора не сможет освободить память. Если для Web-скриптов это не актуально, то для фоновых заданий - скорее всего.

### Усечение данных

Свойство `BaseException::data` попадает в журнал. Хотя данные, которые попадают в журнал сохраняют структуру, и могут быть десериализированы заново, не стоит использовать большие массивы данных. Это не только замедляет процесс обработки журнала, но и создаёт ненужную избыточность. Если в самом деле необходимо сохранять большие массивы данных, лучше использовать отладочный режим.

Для усечения данных можно использовать методы:

- `BaseException::get_type()`;
- `BaseException::truncate()`.

### Использование в data базовых типов

Это требование имеет с одной стороны тот же смысл, что и "Не хранить объекты в исключении". Но главная причина иная. Свойство `data` может участвовать в процессе сериализации исключения. А объекты не всегда можно правильно сериализировать/десериалировать. Хотя можно воспользовать интерфейсом `Serializable` - это не самая хорошая идея, так как целью сериализации могут быть другие форматы, отличные по сути от `Serializable`.

Если вы хотите получить возможность легко сериализировать исключения - пытайтесь строго следовать этому правилу.

## Отладочные данные

Для сохранения отладочных данных, `BaseException` предоставляет метод `set_debug_data()`. Этот метод имеет атрибут `protected`, а значит предназначен только для внутреннего использования.

Алгоритм `BaseException::set_debug_data()`:

1. Проверить, активен ли режим отладки.
2. Если да, перевести данные в строку, и сохранить их.

Пример использования:

```php
    class UnexpectedValue   extends LoggableException
    {
        public function __construct($name, $value = null)
        {
            // Для журнала отладки сохраним полные данные:
            $this->set_debug_data(['value' => $value]);

            parent::__construct
            ([
                    'message'     => 'Unexpected value',
                    'name'        => $name,
                    'type'        => self::get_value_type($value)
            ]);
        }
    }
```

Используя свойство `is_debug`, вы можете насильно записать данные, в независимости от того, включён ли режим отладки или нет:

```php
    class UnexpectedValue   extends LoggableException
    {
        public function __construct($name, $value = null)
        {
            // Принудительное включение режима отладки
            $this->is_debug       = true;
            // Для отладчика сохраним полные данные:
            $this->set_debug_data(['value' => $value]);

            parent::__construct
            ([
                    'message'     => 'Unexpected value',
                    'name'        => $name,
                    'type'        => self::get_value_type($value)
            ]);            
        }
    }
```

При этом отладочные данные запишутся только для вашего исключения. Это позволяет быстро ввести отладочный режим даже на рабочей системе, только в необходимом месте.

Таким же образом, можно и отключить отладочный режим:

```php
    // Все исключения, которые наследуются от этого 
    // получат выключенный отладочный режим
    // (если конечно не переопределят его явно)
    class NoDebugException   extends LoggableException
    {
        protected $is_debug = false;
    }
```

## Сериализация

Кроме основных методов `BaseException` поддерживает сериализацию/десериализацию. Это может быть полезно для маршалинга исключений через удалённые сервисы, сохранения исключений на диск и прочего, где обычно используется сериализация.

Целевым форматом сериализации является асоциативный массив. Массив выбран потому, что его легко преобразовать в любой другой формат: `json`, `xml`, `phpserialize`, etc.

Формат массива:

```php
    [
        'type'      => get_class($exception),
        'source'    => ['source' => '', 'type' => '', 'function' => ''],
        'message'   => $exception->getMessage(),
        'template'	=> $exception->template(),
        'code'      => $exception->getCode(),
        'data'      => $exception->get_data(),
        'container' => 'если это контейнер-исключение'
    ];
```

Исключения контейнеры возвращают сериализацию не самих себя, а исключения `previous`.

За общую сериализацию/десериализацию отвечают статические методы:

- `BaseException::errors_to_array()`;
- `BaseException::array_to_errors()`.

## Особенности

Следующие методы `BaseException` существуют потому, что стандартные методы `PHP` `\Exception` объявлены как `final`, но поведение их не соответствует общей парадигме `BaseException`. 

### Определение источника исключения

Для определения источника исключения используется специальный метод `BaseException::get_source()`. Он возвращает ассоциативный массив вида:

```php
    [
        'source'    => 'класс или файл:строка, где возникло исключение',
        'type'      => 'тип вызова',
        'function'  => 'имя функции или метода, где возникло исключение'
    ];
```

Метод `BaseException::get_source()` используется при журналировании вместо метода `BaseException::getFile()`, потому что определение источника по имени класса является более естественным методом относительно устройства языка. После введения `namespace`  и `autoload` реальная структура файлов больше не имеет большого значения, а информация об `namespace` сохраняется и тогда, когда весь код объединяется в один файл.

Обратите внимание, что порядок ключей в массиве `source` имеет значение, и он создан таким образом, что если выполнить слияние массива в строку, то вы получите строковое указание источника:

```php
    
    namespace Test;
        
    class ZClass
    {
        function zfun()
        {
            throw new BaseException('...');
        }
    }

    try
    {
        $Test = new ZClass();
        $Test->zfun(); 
    }
    catch(BaseException $e)
    {
        // out: Test\ZClass->zfun
        echo implode('', $exception->get_source());        
    }
```

Для вычисления источника классов `PHP` `\Exception` используйте метод `BaseException::get_source_for()`.

### Определение вложенного исключения

`BaseException` создаёт контейнеры для любых объектов, которые поддерживают интерфейс `BaseExceptionI`. Этот приём позволяет оборачивать в исключения другие объекты, которые имеют схожее поведение, но не являются `PHP` исключениями.

Однако `\Exception::$previous` может быть только дочерним объектом от `\Exception`. Чтобы обойти это органичение, `BaseException` помещает объект `BaseExceptionI` в свойство `data` (в контейнере это свойство не используется для данных).

Для доступа к вложенному объекту `BaseExceptionI` следует использовать метод `BaseExceptionI::get_previous()`, который всегда вернёт правильный объект: 

- `\Exception`;
- либо `BaseExceptionI`;
- либо `null`, если объекта нет.

[1]: 04-Logging.md "Журналирование"
