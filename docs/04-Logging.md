# Logging

## Процесс журналирования

Журналирование проходит в два этапа:

1. Исключение попадает в хранилище реестра (`Registry`).
2. Реестр передаёт исключения в журнал.

Для этого, код `BaseException` вызывает `Registry::register_exception(…)`, которая в свою очередь передаёт исключение в глобальное хранилище исключений:

```php
    static public function register_exception($exception)
    {
        ...
        self::$exceptions->add_exception($exception);
        ...
    }
```

Это можно отобразить на схеме:

    __construct -> Registry::register_exception -> StorageI

где:

- `__construct` - конструктор исключения (неважно какого).
- `Registry`      - статический класс.
- `StorageI`      - объект, который на самом деле хранит исключения.

Где же тут журнализатор? Правильно - его здесь нет. И его не должно быть. Так как вопросы журналирования сами по себе никак не относятся к библиотеке `BaseException`.

Единственной точкой интеграции является метод: `Registry::save_exception_log()`.

Он вызывается в тот момент, когда можно сохранить реестр исключений. Когда именно? Всё зависит от ситуации. Например, это может быть момент завершения программы. Всё, что делает этот сложный метод, можно увидеть в коде:

```php
    static public function save_exception_log()
    {
        if(is_callable(self::$save_handler))
        {
            call_user_func(self::$save_handler, …);
        }
    }
```

Метод вызывает зарегестрированный обработчик `$save_handler`, который определяется методом `Registry::set_save_handler($callback)`. Именно на этот обработчик и ложится задача реального журналирования исключений.

## Предпологаемый алгоритм журнализатора

Хотя `BaseException` никак не может повлиять на реализацию журнализатора, тем не менее существует некоторое ожидаемое поведение, которое журнализатор должен поддерживать.

Прототип обработчика `$save_handler`:

```php
    /**
     * Журнализатор исключений.
     *
     * @param array             $exceptions         Хранилище исключений
     * @param callable          $reset_log          Функция сброса журнала
     * @param ArrayAccess       $logger_options     опции журналирования
     * @param ArrayAccess       $debug_options      опции для отладки (профайлинга)
     */
    function save_handler
    (
                    $exceptions, 
        callable    $reset_log, 
                    $logger_options = [], 
                    $debug_options  = []
    )
```

Общий алгоритм:

1. Журнализатор получает список исключений (его копию).
2. Журнализатор обходит список чтобы записать его в журнал.
3. Журнализатор вызывает делегат `$reset_log`, чтобы очистить от журнал исключений.

Порядок действий алгоритма означает, что если работа журнала завершится как-то неожиданно, список исключений останется. Но на самом деле, ситуация сложнее.

Пока журнал записывает данные, в списке исключений могут появится новые записи. Речь не идёт о "паралельных" потоках, а о коде самого журнализатора. Это означает, что журнализатор обязан гарантировать, что ни одно исключение не попадёт в журнал, а если такие исключения и возникнут - они "остаются на совести" у журнализатора.

Каждое исключение поддаётся обработке:

1. Если `is_loggable()` === false, исключение не попадает в журнал!
2. Если `get_debug_data()` не пуст (empty()), тогда реализуется алгоритм записи в журнал для отладки.
3. Определить аспект исключения и журнал, в который оно будет записано.
4. Сериализовать данные и записать в выбранный журнал.

Обратите внимание:

1. Даже, если исключение находится в реестре, оно может не попасть в журнал, если флаг `is_loggable()` на момент реальной журнализации будет равен `false`.
2. В независимости от того включён или нет режим отладки или профилирования, данные `get_debug_data()` должны быть обработаны.
3. Отладочный журнал может находиться отдельно от остальных.

## Управление флагом is_loggable

Только что мы установили важный момент, что любое журналируемое исключение может попасть в реестр исключений, но не попасть в реальный журнал.

Достаточно часто в конструкторе исключения невозможно знать заранее: нужно ли его журнализировать или нет. Например, если файл не доступен, с одной стороны это серьёзная ошибка, а с другой стороны - может быть ожидаемая ошибка. Решение о журналировании должен принять код свыше. Но этот случай так же косвенно указывает на неправильное использование исключений.

С другой стороны, возможна ситуация, в которой код верхнего уровня может поместить в журнал более точное описание ошибки. В этом случае, предыдущее исключение, ему следует  подавить:

```php
    try
    {
        ...
        throw new LoggableException
        (
            'А того великана я знал - он у меня пастухом работал. 
            Да вот беда - на прошлой неделе пил он воду из этой чашки, 
            поскользнулся, упал в нее и утонул. 
            Три дня искали - не нашли, видно, в море унесло…' 
        );
        ...
    }
    catch(BaseException $kingdoms)
    {
        // Полцарства?!
        // Выбрасываем другое исключение, которое попадёт в журнал
        throw new LoggableException
        (
            'неправда',
            0,
            $kingdoms->set_loggable(false)
        );
    }
```

## Аспекты журналирования

Для определения аспектов исключения, используются интерфейсы, так как они являются "естественными элементами языка", могут быть легко проверены и получены, и являются глобальными для всей программы.

`BaseException` предлагает реализацию основных аспектов:

1. Для системных сбоев, используется `SystemExceptionI`.
2. Для сбоев из-за внешних факторов `RuntimeExceptionI`.
3. Отсутствие аспекта - причиной ошибки является сам код программы.

В основном аспекты используются для сортировки потока сообщений:

1. В какой журнал поместить исключение.
2. На какой email отправить уведомление.
3. Как пометить исключение в журнале.

Так как, аспекты определяются в виде интерфейсов, это побуждает:

1. В каждом проекте продумать свои аспекты, если нужно.
2. Не злоупотреблять количеством аспектов.

Что хорошо согласуется с парадигмой: чем меньше аспектов - тем лучше.

`BaseException` убедительно рекомендует **никогда не создавать своих аспектов**. Потому, что число аспектов не зависит от размера системы: будь то Операционная система, или приложение "Hello World".

Если всё таки нужно отделить группу исключений для отдельной подсистемы, нужно перегрузить механизм регистрации исключения в реестре, и использовать другой реестр. Так как, если аспекты являются глобальными для всех компонентов системы, то отдельное журналирование требуется только конкретному модулю.

## Переопределение реестра исключений

Любое дочернее исключение от `BaseException` всегда может переопределить регистрацию исключения:

```php
class MyException extends LoggableException
{
    public function __construct(MyObjectI $object, LoggerI $logger)
    {
        // Сохранить реальное состояние флага
        $is_loggable       = $this->is_loggable;
        
        // Это исключение не попадает в стандартный реестр
        $this->is_loggable = false;
        parent::__construct($this->format_data($object));
            
        $this->is_loggable = $is_loggable;

        if($is_loggable)
        {   
            // Но записывается в свой
            $logger->add_to_log($this);
        }
    }
}
```

Обратите внимание, что код из примера сохраняет логику флага `$is_loggable`, и позволяет наследуемым исключениям переопределять его значение.
